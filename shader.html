<!DOCTYPE html>
<html>
<body>
<canvas id="myCanvas" width="600" height="600" style="border:1px solid #d3d3d3;"></canvas>

<script>
var canvas = document.getElementById("myCanvas");
var gl = canvas.getContext("webgl");

    // setup GLSL program
var vertexShaderSource = `
attribute vec2 position;
void main() {
  gl_Position = vec4(position.xy, 0.0, 1.0);
}`;

var fragmentShaderSourceBufferA = `
//Conventions:
// x component = outer radius / ring
// y component = inner radius / disk
/*
   _
 /   \\
|  O  |
 \\ _ /
*/

precision mediump float;

uniform vec2 iResolution;
uniform sampler2D iChannel0;
uniform sampler2D iChannel1;
uniform sampler2D iChannel2;

uniform int iFrame;
uniform vec4 iMouse;


const float PI = 3.14159265;
const float dt = 0.30;

const vec2 r = vec2(10.0, 3.0);

// SmoothLifeL rules
const float b1 = 0.257;
const float b2 = 0.336;
const float d1 = 0.365;
const float d2 = 0.549;

const float alpha_n = 0.028;
const float alpha_m = 0.147;
/*------------------------------*/

//const float KEY_LEFT  = 37.5/256.0;
const float KEY_UP    = 38.5/256.0;
//const float KEY_RIGHT = 39.5/256.0;
const float KEY_DOWN  = 40.5/256.0;
const float KEY_SPACE  = 32.5/256.0;


// 1 out, 3 in... <https://www.shadertoy.com/view/4djSRW>
#define MOD3 vec3(.1031,.11369,.13787)
float hash13(vec3 p3) {
    p3 = fract(p3 * MOD3);
    p3 += dot(p3, p3.yzx+19.19);
    return fract((p3.x + p3.y)*p3.z);
}


/* ---------------- Sigmoid functions ------------------------------------ */

// TODO: reduce unnecessary parameters (remove arguments, use global consts)

float sigmoid_a(float x, float a, float b) {
    return 1.0 / (1.0 + exp(-(x - a) * 4.0 / b));
}

// unnecessary
float sigmoid_b(float x, float b, float eb) {
    return 1.0 - sigmoid_a(x, b, eb);
}

float sigmoid_ab(float x, float a, float b, float ea, float eb) {
    return sigmoid_a(x, a, ea) * sigmoid_b(x, b, eb);
}

float sigmoid_mix(float x, float y, float m, float em) {
    return x * (1.0 - sigmoid_a(m, 0.5, em)) + y * sigmoid_a(m, 0.5, em);
}

/* ----------------------------------------------------------------------- */

// SmoothLifeL
float transition_function(vec2 disk_ring) {
    return sigmoid_mix(sigmoid_ab(disk_ring.x, b1, b2, alpha_n, alpha_n),
                       sigmoid_ab(disk_ring.x, d1, d2, alpha_n, alpha_n), disk_ring.y, alpha_m
                      );
}

// unnecessary (?)
float ramp_step(float steppos, float t) {
    return clamp(t-steppos+0.5, 0.0, 1.0);
}

// unnecessary
vec2 wrap(vec2 position) { return fract(position); }

// Computes both inner and outer integrals
// TODO: Optimize. Much redundant computation. Most expensive part of program.
vec2 convolve(vec2 uv) {
    vec2 result = vec2(0.0);
    for (float dx = -r.x; dx <= r.x; dx++) {
        for (float dy = -r.x; dy <= r.x; dy++) {
            vec2 d = vec2(dx, dy);
            float dist = length(d);
            vec2 offset = d / iResolution.xy;
            vec2 samplepos = wrap(uv + offset);
            //if(dist <= r.y + 1.0) {
                float weight = texture2D(iChannel0, samplepos).x;
                result.x += weight * ramp_step(r.y, dist) * (1.0-ramp_step(r.x, dist));

            //} else if(dist <= r.x + 1.) {
                //float weight = texture2D(iChannel0, uv+offset).x;
                result.y += weight * (1.0-ramp_step(r.y, dist));
            //}
        }
    }
    return result;
}

void main()
{
    vec2 fragCoord = gl_FragCoord.xy;
    vec3 color = vec3(0.0);

    vec2 uv = fragCoord.xy / iResolution.xy;

    // Compute inner disk and outer ring area.
    vec2 area = PI * r * r;
    area.x -= area.y;
    /* -------------------------------------*/

    // TODO: Cleanup.
    color = texture2D(iChannel0, uv).xyz;
    vec2 normalized_convolution = convolve(uv.xy).xy / area;
    color.x = color.x + dt * (2.0 * transition_function(normalized_convolution) - 1.0);
    color.yz = normalized_convolution;
    color = clamp(color, 0.0, 1.0);

    // Set initial conditions. TODO: Move to function / cleanup
    if(iFrame < 10 || texture2D( iChannel2, vec2(KEY_SPACE,0.5) ).x > 0.5) {
        color = vec3(hash13(vec3(fragCoord, iFrame)) - texture2D(iChannel1, uv).x + 0.5);
    }

    if(iMouse.z > 0.) {
        //vec2 dst = abs(uv - iMouse.xy/iResolution.xy);
        float dst = length((fragCoord.xy - iMouse.xy)/iResolution.xx);
        /*if(max(dst.x * iResolution.x/iResolution.y, dst.y) < 0.05) {
            color = vec3(hash13(vec3(fragCoord, iFrame)) - texture2D(iChannel1, uv).x + 0.5);
        }*/
        if(dst <= (r.x)/iResolution.x) {
            color.x = step((r.y+1.5)/iResolution.x, dst) * (1.0 - step(r.x/iResolution.x, dst));
        }
        /*if(dst <= (r.x)/iResolution.x) {
            color.x = step((r.y+1.0)/iResolution.x, dst) * (1.0 - step((r.x-0.5)/iResolution.x, dst));
        }*/
    }

    // Inspect transition function. TODO: Move to function / ifdef
    if(texture2D( iChannel2, vec2(KEY_DOWN, 5.0/3.0) ).x > 0.5) {
        color = vec3(transition_function(uv));
    }

    if(texture2D( iChannel2, vec2(KEY_UP, 0.5)).x > 0.5) {
        color = vec3(0.0);
    }

    gl_FragColor = vec4(color, 1.0);
}
`;

var fragmentShaderSourceImage = `
precision mediump float;

uniform vec2 iResolution;
uniform sampler2D iChannel0;
uniform sampler2D iChannel1;
uniform sampler2D iChannel2;

const vec3 CellColor = vec3(0.2, 0.2, 0.2);
const vec3 RingColor = vec3(0.0, 0.2, 0.2);
const vec3 DiskColor = vec3(0.0, 0.0, 0.0);

void main()
{
    vec2 fragCoord = gl_FragCoord.xy;
    vec2 uv = fragCoord.xy / iResolution.xy;

    vec4 buffer = texture2D(iChannel0, uv);

    vec3 color = 1.0*(buffer.x * CellColor + buffer.y * RingColor + buffer.z * DiskColor);

    float c = 1.0 - buffer.z;
    float c2 = 1. - texture2D(iChannel0, uv + .5/iResolution.xy).y;
    color += vec3(.6, .85, 1.)*max(c2*c2 - c*c, 0.)*4.;


    gl_FragColor = vec4(color, 1.0);
}
`;

// compile and link the two programs
var programBufferA = createProgram(gl, vertexShaderSource, fragmentShaderSourceBufferA);
var programImage = createProgram(gl, vertexShaderSource, fragmentShaderSourceImage);

// setup buffers and uniforms
// create a texture
var texture = gl.createTexture();
gl.bindTexture(gl.TEXTURE_2D, texture);
gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 512, 512, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

// create a framebuffer
var framebuffer = gl.createFramebuffer();
gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);

if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) != gl.FRAMEBUFFER_COMPLETE) {
    iwjeifoaejwf;
    // The framebuffer is not complete, handle the error
}

let frame = 0;

// rendering loop
function render(time) {
    // bind the framebuffer and use the program for the first pass
    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
    gl.useProgram(programBufferA);
    gl.bindTexture(gl.TEXTURE_2D, null);

    // set uniforms here for fragmentShaderSourceBufferA
    let iChannel0Location = gl.getUniformLocation(programBufferA, "iChannel0");
    gl.uniform1i(iChannel0Location, 0);
    let iChannel1Location = gl.getUniformLocation(programBufferA, "iChannel1");
    gl.uniform1i(iChannel1Location, 1);
    let iChannel2Location = gl.getUniformLocation(programBufferA, "iChannel2");
    gl.uniform1i(iChannel2Location, 2);
    let iResolutionLocation = gl.getUniformLocation(programBufferA, "iResolution");
    gl.uniform2f(iResolutionLocation, canvas.width, canvas.height);
    let iFrameLocation = gl.getUniformLocation(programBufferA, "iFrame");
    gl.uniform1i(iFrameLocation, frame++);

    gl.drawArrays(gl.TRIANGLES, 0, 6);

    // use the program for the second pass
    // Unbind the framebuffer before the second pass
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.useProgram(programImage);

    // Bind the texture we rendered to in the first pass
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, texture);

    // set uniforms here for fragmentShaderSourceBufferA
    iChannel0Location = gl.getUniformLocation(programImage, "iChannel0");
    gl.uniform1i(iChannel0Location, 0);
    iChannel1Location = gl.getUniformLocation(programImage, "iChannel1");
    gl.uniform1i(iChannel1Location, 1);
    iChannel2Location = gl.getUniformLocation(programImage, "iChannel2");
    gl.uniform1i(iChannel2Location, 2);
    iResolutionLocation = gl.getUniformLocation(programImage, "iResolution");
    gl.uniform2f(iResolutionLocation, canvas.width, canvas.height);

    gl.drawArrays(gl.TRIANGLES, 0, 6);

    // Unbind the framebuffer after rendering
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    requestAnimationFrame(render);
}

// start the rendering loop
requestAnimationFrame(render);

// function for creating a shader
function createShader(gl, type, source) {
    var shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    return shader;
}

// function for creating a program
function createProgram(gl, vertexShaderSource, fragmentShaderSource) {
    var program = gl.createProgram();
    const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
    const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error(gl.getProgramInfoLog(program));
        console.error(gl.getShaderInfoLog(vertexShader));
        console.error(gl.getShaderInfoLog(fragmentShader));
    }
    return program;
}
</script>

</body>
</html>
||||||| 6b372f8
=======
<!DOCTYPE html>
<html>
<head>
    <title>SmoothLife</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { width: 100vh; height: 100vh; display:block; }
    </style>
</head>
<body>
<canvas id="smoothcanvas"></canvas>

<script>
const canvas = document.getElementById('smoothcanvas');
const WIDTH = Math.floor(canvas.clientWidth / 8);
const HEIGHT = Math.floor(canvas.clientHeight / 8);



function randomGrid() {
    const grid = [];
    for (let i = 0; i < HEIGHT; i++) {
        grid[i] = [];
        for (let j = 0; j < WIDTH; j++) {
            grid[i][j] = Math.random();
        }
    }
    return grid;
}

const GRID = randomGrid();
const GRID_DIFF = randomGrid();
const RA = 21;
const ALPHA_N = 0.028;
const ALPHA_M = 0.147;
const B1 = 0.257;
const B2 = 0.336;
const D1 = 0.365;
const D2 = 0.549;
const DT = 0.05;



const context = canvas.getContext('2d');

function displayGrid() {
    const imageData = context.createImageData(WIDTH, HEIGHT);
    for (let i = 0; i < HEIGHT; i++) {
        for (let j = 0; j < WIDTH; j++) {
            const index = (i * WIDTH + j) * 4;
            const value = GRID[i][j];
            imageData.data[index + 0] = value * 255;
            imageData.data[index + 1] = value * 255;
            imageData.data[index + 2] = value * 255;
            imageData.data[index + 3] = 255;
        }
    }
    context.putImageData(imageData, 0, 0);
}

function emod(a, b) {
    return (a%b + b)%b;
}

function sigma(x, a, alpha) {
    return 1.0/(1.0 + Math.exp(-(x - a)*4/alpha));
}

function sigma_n(x, a, b) {
    return sigma(x, a, ALPHA_N)*(1 - sigma(x, b, ALPHA_N));
}

function sigma_m(x, y, m) {
    return x*(1 - sigma(m, 0.5, ALPHA_M)) + y*sigma(m, 0.5, ALPHA_M);
}

function s(n, m) {
    return sigma_n(n, sigma_m(B1, D1, m), sigma_m(B2, D2, m));
}

function computeGridDiff() {
    for (let cy = 0; cy < HEIGHT; ++cy) {
        for (let cx = 0; cx < WIDTH; ++cx) {
            let m = 0;
            let M = 0;
            let n = 0;
            let N = 0;
            const ri = RA/3;

            for (let dy = -(RA - 1); dy <= (RA - 1); ++dy) {
                for (let dx = -(RA - 1); dx <= (RA - 1); ++dx) {
                    let x = emod(cx + dx, WIDTH);
                    let y = emod(cy + dy, HEIGHT);
                    if (dx*dx + dy*dy <= ri*ri) {
                        m += GRID[y][x];
                        M += 1;
                    } else if (dx*dx + dy*dy <= RA*RA) {
                        n += GRID[y][x];
                        N += 1;
                    }
                }
            }
            m /= M;
            n /= N;
            const q = s(n, m);
            GRID_DIFF[cy][cx] = 2*q - 1;
        }
    }
}

function clamp(x, min, max) {
    return Math.min(Math.max(x, min), max);
}

function applyGridDiff() {
    for (let i = 0; i < HEIGHT; ++i) {
        for (let j = 0; j < WIDTH; ++j) {
            GRID[i][j] = clamp(GRID[i][j] + GRID_DIFF[i][j]*DT, 0, 1);
        }
    }
}

function keepDisplayingGrid() {
    displayGrid();
    requestAnimationFrame(keepDisplayingGrid);
}
keepDisplayingGrid();

function update() {
    computeGridDiff();
    applyGridDiff();
    setTimeout(update, 0);
}
update();

</script>
</body>
</html>
