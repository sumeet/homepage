<!DOCTYPE html>
<html>
<head>
    <title>SmoothLife</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { width: 100vh; height: 100vh; display:block; }
    </style>
</head>
<body>
<canvas id="smoothcanvas"></canvas>

<script>
const canvas = document.getElementById('smoothcanvas');
const WIDTH = Math.floor(canvas.clientWidth / 8);
const HEIGHT = Math.floor(canvas.clientHeight / 8);



function randomGrid() {
    const grid = [];
    for (let i = 0; i < HEIGHT; i++) {
        grid[i] = [];
        for (let j = 0; j < WIDTH; j++) {
            grid[i][j] = Math.random();
        }
    }
    return grid;
}

const GRID = randomGrid();
const GRID_DIFF = randomGrid();
const RA = 21;
const ALPHA_N = 0.028;
const ALPHA_M = 0.147;
const B1 = 0.257;
const B2 = 0.336;
const D1 = 0.365;
const D2 = 0.549;
const DT = 0.05;



const context = canvas.getContext('2d');

function displayGrid() {
    const imageData = context.createImageData(WIDTH, HEIGHT);
    for (let i = 0; i < HEIGHT; i++) {
        for (let j = 0; j < WIDTH; j++) {
            const index = (i * WIDTH + j) * 4;
            const value = GRID[i][j];
            imageData.data[index + 0] = value * 255;
            imageData.data[index + 1] = value * 255;
            imageData.data[index + 2] = value * 255;
            imageData.data[index + 3] = 255;
        }
    }
    context.putImageData(imageData, 0, 0);
}

function emod(a, b) {
    return (a%b + b)%b;
}

function sigma(x, a, alpha) {
    return 1.0/(1.0 + Math.exp(-(x - a)*4/alpha));
}

function sigma_n(x, a, b) {
    return sigma(x, a, ALPHA_N)*(1 - sigma(x, b, ALPHA_N));
}

function sigma_m(x, y, m) {
    return x*(1 - sigma(m, 0.5, ALPHA_M)) + y*sigma(m, 0.5, ALPHA_M);
}

function s(n, m) {
    return sigma_n(n, sigma_m(B1, D1, m), sigma_m(B2, D2, m));
}

function computeGridDiff() {
    for (let cy = 0; cy < HEIGHT; ++cy) {
        for (let cx = 0; cx < WIDTH; ++cx) {
            let m = 0;
            let M = 0;
            let n = 0;
            let N = 0;
            const ri = RA/3;

            for (let dy = -(RA - 1); dy <= (RA - 1); ++dy) {
                for (let dx = -(RA - 1); dx <= (RA - 1); ++dx) {
                    let x = emod(cx + dx, WIDTH);
                    let y = emod(cy + dy, HEIGHT);
                    if (dx*dx + dy*dy <= ri*ri) {
                        m += GRID[y][x];
                        M += 1;
                    } else if (dx*dx + dy*dy <= RA*RA) {
                        n += GRID[y][x];
                        N += 1;
                    }
                }
            }
            m /= M;
            n /= N;
            const q = s(n, m);
            GRID_DIFF[cy][cx] = 2*q - 1;
        }
    }
}

function clamp(x, min, max) {
    return Math.min(Math.max(x, min), max);
}

function applyGridDiff() {
    for (let i = 0; i < HEIGHT; ++i) {
        for (let j = 0; j < WIDTH; ++j) {
            GRID[i][j] = clamp(GRID[i][j] + GRID_DIFF[i][j]*DT, 0, 1);
        }
    }
}

function keepDisplayingGrid() {
    displayGrid();
    requestAnimationFrame(keepDisplayingGrid);
}
keepDisplayingGrid();

function update() {
    computeGridDiff();
    applyGridDiff();
    setTimeout(update, 0);
}
update();

</script>
</body>
</html>
